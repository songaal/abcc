package org.fastcatsearch.datasource.reader;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.fastcatsearch.datasource.SourceModifier;
import org.fastcatsearch.env.Path;
import org.fastcatsearch.ir.common.IRException;
import org.fastcatsearch.ir.config.SingleSourceConfig;
import org.fastcatsearch.ir.index.DeleteIdSet;
import org.fastcatsearch.ir.settings.SchemaSetting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class SingleSourceReader<SourceType> {

	protected static Logger logger = LoggerFactory.getLogger(SingleSourceReader.class);

	protected Path filePath;
	protected SingleSourceConfig singleSourceConfig;
	protected String lastIndexTime; // 마지막 수집시작.(시작시각)

	protected SourceModifier<SourceType> sourceModifier;
	protected DeleteIdSet deleteIdList;

	private List<SourceReaderParameter> sourceReaderParameterList;
	private Map<String, String> parameterMap;
	private String collectionId;

	protected int maxRows;
	
	public abstract void init() throws IRException, IOException; // 초기화. 파일을 여는등의 작업.

	public abstract boolean hasNext() throws IRException, IOException;

	protected abstract SourceType next() throws IRException, IOException;

	public void close() throws IRException {
		if(sourceModifier != null){
			sourceModifier.close();
		}
	}

	// reader에서 사용하는 파라미터를 정의한다.
	protected abstract void initParameters();
	
	public void setMaxRows(int maxRows){
		this.maxRows = maxRows;
	}
	
	// reader에서 소스셋팅을 기반으로 기본 스키마 셋팅을 자동으로 만들어준다.
	// 자동스키마 생성을 제공하지 않을시는 구현하지 않고, null을 리턴하도록한다.
	public SchemaSetting getAutoGeneratedSchemaSetting() {
		return null;
	}

	public SingleSourceReader() {
		initParameters();
	}

	public SingleSourceReader(String collectionId, File filePath, SingleSourceConfig singleSourceConfig, SourceModifier<SourceType> sourceModifier,
			String lastIndexTime) {
		this.collectionId = collectionId;
		this.filePath = new Path(filePath);
		this.singleSourceConfig = singleSourceConfig;
		this.lastIndexTime = lastIndexTime;
		this.sourceModifier = sourceModifier;
		if(sourceModifier != null){
			sourceModifier.setSourceReader(this);
			sourceModifier.init();
		}
		initParameters();
		fillParameters(singleSourceConfig.getProperties());
	}

	protected void registerParameter(SourceReaderParameter parameter) {
		if (sourceReaderParameterList == null) {
			sourceReaderParameterList = new ArrayList<SourceReaderParameter>();
		}
		sourceReaderParameterList.add(parameter);
	}

	public List<SourceReaderParameter> getParameterList() {
		return sourceReaderParameterList;
	}

	public boolean isActive(){
		if(singleSourceConfig != null) {
			return singleSourceConfig.isActive();
		} else {
			return true;
		}
	}
	public String getCollectionId() {
		return collectionId;
	}
	
	private void fillParameters(Map<String, String> map) {
		// xml에서 읽어들인 파리미터들을 객체에 채워넣는다.
//		logger.debug("map:{}", map);
		if(map!=null) {
			for (Entry<String, String> entry : map.entrySet()) {
				String key = entry.getKey();
				for (SourceReaderParameter parameter : sourceReaderParameterList) {
					if (key.equalsIgnoreCase(parameter.getId())) {
						// 해당 parameter에 값을 넣어준다.
						String value = entry.getValue();
						parameter.setValue(value);
	
						if (parameterMap == null) {
							parameterMap = new HashMap<String, String>();
						}
						parameterMap.put(key, value);
						break;
					}
				}
			}
		}
	}

	protected SourceType nextElement() throws IRException, IOException {

		// modifier를 태운다.
		SourceType source = next();
		if (sourceModifier != null) {
			while(true) {
				try {
					sourceModifier.modify(source);
					break;
				} catch (DocumentSkipException e) {
					source = next();
					if(source == null) {
						break;
					}
				}
			}
		}

		return source;
	}

	public void setDeleteIdList(DeleteIdSet deleteIdList) {
		this.deleteIdList = deleteIdList;
	}

	public String getConfigValue(String key) {
		if (parameterMap != null) {
			return parameterMap.get(key);
		} else {
			return null;
		}
	}

	public String getConfigString(String key) {
		return getConfigString(key, null);
	}

	public String getConfigString(String key, String defaultValue) {
		String value = getConfigValue(key);
		return value == null ? defaultValue : value;
	}

	public boolean getConfigBoolean(String key) {
		return getConfigBoolean(key, false);
	}

	public boolean getConfigBoolean(String key, boolean defaultValue) {
		return "true".equalsIgnoreCase(getConfigValue(key));
	}

	public int getConfigInt(String key) {
		return getConfigInt(key, 0);
	}

	public int getConfigInt(String key, int defaultValue) {
		try {
			return Integer.parseInt(getConfigValue(key));
		} catch (NumberFormatException e) {
			return defaultValue;
		}
	}

	public long getConfigLong(String key) {
		return getConfigLong(key, 0L);
	}

	public long getConfigLong(String key, long defaultValue) {
		try {
			return Long.parseLong(getConfigValue(key));
		} catch (NumberFormatException e) {
			return defaultValue;
		}
	}
	
	public Path filePath(){
		return filePath;
	}
}
